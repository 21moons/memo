# 0 [快速入门]网络游戏编程

## 0.2 套接字编程入门--处理多个并发连接, 追求性能

### 0.2.6 单线程, 非阻塞, 事件驱动--使用 select 函数进行轮询

```c
int sock = socket(PF_INET, SOCK_STREAM);
bind(sock, addr);
listen(sock);

allsock.add(sock);
while (1) {
    result = select(sock);
    if(result > 0) {
        int new_sock = accept(sock, &addr);
        allsock.add(new_sock);
    }

    foreach(sock = allsock){
        result = select(sock);
        if(result > 0) {
            char buf[100];
            size_t size = read(new_sock, buf, 100);

            if(size == 0) {
                close(new_sock);
            } else {
                write(new_sock, buf, size);
            }
        }
    }
}
```

### 0.2.7 网络游戏输入输出的特点--单线程, 事件驱动, 非阻塞

### 0.2.9 充分发挥性能和提高开发效率--从实现语言到底层结构

软件性能与开发效率是矛盾的

C/C++ > java > 脚本语言

<p align="left"><font size=2>表 0.1 主要的编程语言与吞吐量</font></p>

| 语言 | 吞吐量 | 特性 |
| ------| ------ | ------ |
| C/C++ | 100 | 静态类型, 本地代码 |
| Java/C# | 1 ~ 10 | 静态类型, VM, 字节码 |
| Ruby/Python | 0.1 ~ 1 | 动态类型 |

对于 CPU 密集型应用程序, Java 的运行速度与 C 近似.
但是对于 IO 密集型应用程序, 因为 Java 虚拟机每次进行系统调用, 都会进行缓存溢出检查和异常对象处理, 所以运行速度比 C 慢上 10 倍左右.

动态类型语言则比 Java 更慢, 因为每次进行一些处理时, 对象调用的方法都可能会发生变化, 所以每次调用前都必须进行检查确认.

Go 语言是一种静态的, 本地执行的语言, 它具有垃圾回收机制, 程序员可以在代码的不同部分中选择类型化的强度.

### 0.2.10 发挥多核服务器的性能

在 Linux 上, 平均每个 CPU 内核一秒内可以执行 10 万~20 万次上下文切换.(这里的上下文切换指的是操作系统调度单元的切换)

### 0.2.12 简化服务器实现--libevent

libevent 单线程 + 事件驱动 + 非阻塞调用

libevent 最大的特点就是: 它的工作方式并非创建大量线程然会等待 read 等系统调用, 而是"不创建线程, 为每一个想要事先通知的事件注册回调函数, 当事件发生时, 只进行一次函数调用"

## 0.3 RPC指南--最简单的通信中间件

DSL(Domain Specific Language 领域特定语言)
IDL(Interface Description Language 接口描述语言)

Protocol Buffers
Thrift

### 0.4.4 游戏编程精粹--不使用线程的"任务系统"

游戏中的许多物体在同一时刻看上去都在各自运动, 但在系统中并没有用多个线程来并行处理.因此游戏一般是按帧来运算的, 用一个或几个定时循环的线程处理事件来表达场景中的所有物体.

### 2.5.2 网络游戏服务运营的3项专门职责

* 开发
* 运维
* 销售

## 2.7 支持网络游戏的技术的大类

<p align="left"><font size=2>表 2.2 物理结构上的分类及其性质上的差异</font></p>

|  | C/S | P2P |
| ------| ------ | ------ |
| 延迟(所需时间, 通信延迟) | 大 | 小 |
| 服务器设备成本 | 大 | 小 |
| 带宽成本 | 根据游戏内容决定 | 根据游戏内容决定 |
| 非法行为 | 困难 | 容易 |

MMO Massively Multiplayer Online
MO  Multi-player Online

<p align="left"><font size=2>表 2.3 逻辑结构上的分类及特征</font></p>

|  | MO | MMO |
| ------| ------ | ------ |
| 游戏核心 | 少量玩家聚集在一起竞赛 | 大量玩家进行社交活动 |
| 同时玩家数 | 20 左右 | 200~1000000 |
| 延迟 | 50 毫秒 | 300 毫秒 |
| 游戏时间(累积) | 几分钟 | 几年 |
| RMT(真实货币交易, Real Money Trading) | 很少 | 活跃 |
| 平台 | 游戏机 | PC, 移动设备 |

网络游戏的4种形式--物理结构 * 逻辑结构
物理结构有 C/S 和 P2P 两种, 逻辑结构有 MO 和 MMO 两种, 共有四种组合

<p align="left"><font size=2>表 2.4 网络游戏的4种形式及游戏类型</font></p>

|  | MO | MMO |
| ------| ------ | ------ |
| C/S | 休闲游戏 | MMORPG 虚拟世界 |
| P2P | ARPG(动作类 RPG), 对战格斗游戏, FPS, 竞速游戏, RTS, 射击游戏 | N/A |

### 2.8.2 支持网络游戏主体的3大核心

* 游戏的数据形式
* 游戏的通信方式
* 游戏的反应速度(延迟)
显示器每秒进行几十次的画面更新, 这种画面更新时间对玩家来说, 就是游戏状态变化的最短时间间隔

<p align="left"><font size=2>表 2.5 网络延迟与实现方法</font></p>

| 名称 | 延迟 | 同步/异步 | 冗长 | 补充 |
| ------| ------ | ------ |
| 同步方式 | 25毫秒以下 | 同步 | 非冗余 | 在高速网络的前提下, 同步方式的实现方法比较好 |
| 异步方式 | 100毫秒以下 | 非同步 | 冗余 | 为了在低速的网络上实现高速的游戏, 冗余性是必需的 |
| 浏览器方式 | 300毫秒以下 | 非同步 | 非冗余 | 延迟的程度超出了用冗余性可以解决的范围, 所以将游戏数据和游戏客户端(游戏浏览器)完全分离 |

同步方式是指, 运行在所有游戏玩家设备上的程序是同步的, 只要一个人的网络发生延迟, 后台程序的运行就会变慢, 所有人都会受影响.
异步方式是指, 各个终端上的游戏进行状态是异步的, 就算某台终端上的程序停止运行, 其他终端的程序也能照常运行, 但是会看到问题终端对应的角色出现卡死
浏览器方式是指所有游戏内容都运行在后来, 前台只起到显示的作用, 这样即使服务器以外的所有程序都停止运行, 程序也能继续运行, 不会发生数据不匹配.

* 游戏处理的冗余化 --> 解决主数据和副本数据之间的关系
* 游戏处理的异步化 --> 解决数据变化时同步处理(锁)和异步处理之间的关系

### 3.1.2 将数据存放在内存中的理由

