# 0 [快速入门]网络游戏编程

## 0.2 套接字编程入门--处理多个并发连接, 追求性能

### 0.2.6 单线程, 非阻塞, 事件驱动--使用 select 函数进行轮询

```c
int sock = socket(PF_INET, SOCK_STREAM);
bind(sock, addr);
listen(sock);

allsock.add(sock);
while (1) {
    result = select(sock);
    if(result > 0) {
        int new_sock = accept(sock, &addr);
        allsock.add(new_sock);
    }

    foreach(sock = allsock){
        result = select(sock);
        if(result > 0) {
            char buf[100];
            size_t size = read(new_sock, buf, 100);

            if(size == 0) {
                close(new_sock);
            } else {
                write(new_sock, buf, size);
            }
        }
    }
}
```

### 0.2.7 网络游戏输入输出的特点--单线程, 事件驱动, 非阻塞

### 0.2.9 充分发挥性能和提高开发效率--从实现语言到底层结构

软件性能与开发效率是矛盾的

C/C++ > java > 脚本语言

<p align="left"><font size=2>表 0.1 主要的编程语言与吞吐量</font></p>

| 语言 | 吞吐量 | 特性 |
| ------| ------ | ------ |
| C/C++ | 100 | 静态类型, 本地代码 |
| Java/C# | 1 ~ 10 | 静态类型, VM, 字节码 |
| Ruby/Python | 0.1 ~ 1 | 动态类型 |

对于 CPU 密集型应用程序, Java 的运行速度与 C 近似.
但是对于 IO 密集型应用程序, 因为 Java 虚拟机每次进行系统调用, 都会进行缓存溢出检查和异常对象处理, 所以运行速度比 C 慢上 10 倍左右.

动态类型语言则比 Java 更慢, 因为每次进行一些处理时, 对象调用的方法都可能会发生变化, 所以每次调用前都必须进行检查确认.

Go 语言是一种静态的, 本地执行的语言, 它具有垃圾回收机制, 程序员可以在代码的不同部分中选择类型化的强度.

### 0.2.10 发挥多核服务器的性能

在 Linux 上, 平均每个 CPU 内核一秒内可以执行 10 万~20 万次上下文切换.(这里的上下文切换指的是操作系统调度单元的切换)

### 0.2.12 简化服务器实现--libevent

libevent 单线程 + 事件驱动 + 非阻塞调用

libevent 最大的特点就是: 它的工作方式并非创建大量线程然会等待 read 等系统调用, 而是"不创建线程, 为每一个想要事先通知的事件注册回调函数, 当事件发生时, 只进行一次函数调用"

## 0.3 RPC指南--最简单的通信中间件

DSL(Domain Specific Language 领域特定语言)
IDL(Interface Description Language 接口描述语言)

Protocol Buffers
Thrift

### 0.4.4 游戏编程精粹--不使用线程的"任务系统"

游戏中的许多物体在同一时刻看上去都在各自运动, 但在系统中并没有用多个线程来并行处理.因此游戏一般是按帧来运算的, 用一个或几个定时循环的线程处理事件来表达场景中的所有物体.

### 2.5.2 网络游戏服务运营的3项专门职责

* 开发
* 运维
* 销售

## 2.7 支持网络游戏的技术的大类

<p align="left"><font size=2>表 2.2 物理结构上的分类及其性质上的差异</font></p>

|  | C/S | P2P |
| ------| ------ | ------ |
| 延迟(所需时间, 通信延迟) | 大 | 小 |
| 服务器设备成本 | 大 | 小 |
| 带宽成本 | 根据游戏内容决定 | 根据游戏内容决定 |
| 非法行为 | 困难 | 容易 |

MMO Massively Multiplayer Online
MO  Multi-player Online

<p align="left"><font size=2>表 2.3 逻辑结构上的分类及特征</font></p>

|  | MO | MMO |
| ------| ------ | ------ |
| 游戏核心 | 少量玩家聚集在一起竞赛 | 大量玩家进行社交活动 |
| 同时玩家数 | 20 左右 | 200~1000000 |
| 延迟 | 50 毫秒 | 300 毫秒 |
| 游戏时间(累积) | 几分钟 | 几年 |
| RMT(真实货币交易, Real Money Trading) | 很少 | 活跃 |
| 平台 | 游戏机 | PC, 移动设备 |

网络游戏的4种形式--物理结构 * 逻辑结构
物理结构有 C/S 和 P2P 两种, 逻辑结构有 MO 和 MMO 两种, 共有四种组合

<p align="left"><font size=2>表 2.4 网络游戏的4种形式及游戏类型</font></p>

|  | MO | MMO |
| ------| ------ | ------ |
| C/S | 休闲游戏 | MMORPG 虚拟世界 |
| P2P | ARPG(动作类 RPG), 对战格斗游戏, FPS, 竞速游戏, RTS, 射击游戏 | N/A |

### 2.8.2 支持网络游戏主体的3大核心

* 游戏的数据形式
* 游戏的通信方式
* 游戏的反应速度(延迟)

显示器每秒进行几十次的画面更新, 这种画面更新时间对玩家来说, 就是游戏状态变化的最短时间间隔

<p align="left"><font size=2>表 2.5 网络延迟与实现方法</font></p>

| 名称 | 延迟 | 同步/异步 | 冗长 | 补充 |
| ------| ------ | ------ |
| 同步方式 | 25毫秒以下 | 同步 | 非冗余 | 在高速网络的前提下, 同步方式的实现方法比较好 |
| 异步方式 | 100毫秒以下 | 非同步 | 冗余 | 为了在低速的网络上实现高速的游戏, 冗余性是必需的 |
| 浏览器方式 | 300毫秒以下 | 非同步 | 非冗余 | 延迟的程度超出了用冗余性可以解决的范围, 所以将游戏数据和游戏客户端(游戏浏览器)完全分离 |

同步方式是指, 运行在所有游戏玩家设备上的程序是同步的, 只要一个人的网络发生延迟, 后台程序的运行就会变慢, 所有人都会受影响.
异步方式是指, 各个终端上的游戏进行状态是异步的, 就算某台终端上的程序停止运行, 其他终端的程序也能照常运行, 但是会看到问题终端对应的角色出现卡死
浏览器方式是指所有游戏内容都运行在后来, 前台只起到显示的作用, 这样即使服务器以外的所有程序都停止运行, 程序也能继续运行, 不会发生数据不匹配.

* 游戏处理的冗余化 --> 解决主数据和副本数据之间的关系
* 游戏处理的异步化 --> 解决数据变化时同步处理(锁)和异步处理之间的关系

### 3.1.2 将数据存放在内存中的理由

### 3.1.3 每 16 毫秒变化一次--处理的信息及其大小

### 3.1.4 大量对象的显示--CPU 的处理能力

游戏是按帧来处理的, 假设 1 秒钟有 60 帧, CPU 的主频是 1.79 MHz, 那么对于每一帧游戏画面, CPU 大约有 3 万个时钟周期可用(1790000/60 = 29666).

要让游戏世界中的物体移动起来, 必须进行以下处理: 读取坐标, 读取速度, 进行计算, 保存结果. 使用 6502 处理器的命令集处理以上操作需要 2~8 个周期, 假设在效率较高的程序中需要 4 个周期, 而且游戏场景中有 8 个物体, 那么要对二维坐标中 X, Y 两个数据各处理一次, 总共需要 `(4 + 4 + 4 + 4) * 2 * 8 = 256` 个周期, 相对于 CPU 3 万周期的处理能力可谓十分充裕.

接着需要判断己方子弹是否击中了敌人, 假设要对正在飞行的 8 个物体全部进行碰撞检测, 那么就必须进行 `8 * 8 = 64` 次检测, 碰撞检测不能根据两个物体的坐标是否一致来进行判断, 而是必须通过矩形来判断, 所以需要进行二次比较. 因此处理过程如下: 读取坐标, 二次比较, 判断结果. 这次没想处理需要 10 个周期, 又因为要处理 X, Y 坐标, 所以还要翻一倍, 最终需要 `(10 + 10 + 10 + 10) * 2 * (8 * 8) = 5120` 个周期, 再加上移动处理的 256 个周期, 也就 5400 个周期不好, 看上去还挺宽裕的.

家用游戏机上的经典游戏通常有 20 个左右的角色登场. 若对 20 个对象进行碰撞检测, 根据上面的计算方式, 需要 `(10 + 10 + 10 + 10) * 2 * (20 * 20) = 32000` 个周期, 这样就超过了 3 万周期的上限. 另外这里还没有考虑其他操作以及声音处理, 因此必须采取一些优化措施来降低所消耗的周期, 比如, 把"己方子弹之间不会发生碰撞", "敌方子弹与己方子弹不会发生碰撞" 等游戏内容考虑在内.

当 CPU 运算能力不足时, 游戏画面的刷新率就会降低, 导致游戏中物体的运动变得迟缓, 导致游戏体验急剧下降.

* 假设在家用游戏机中使用 RDBMS, 那么就必须通过 SQL 语句, 但是像 SELECT * from FlyingObjects 这样的语句, 单单判断语法是否正确就要消耗几百个 CPU 周期, 显然不现实. 游戏编程必须在 1 帧内完成坐标的判断和保存. 为此, 必须只通过组合 CPU 所具有的一些最原始的命令来实现, 只是读取数据就要花费几百个周期是相当不合理的. 因此, 在家用游戏机中, 基本不考虑使用 RDBMS 这种方式.

### 3.1.5 无法预测玩家的操作--游戏状态千变万化(难以优化)

### 3.1.6 必须将游戏数据放在 CPU 所在的机器上

综合 3.1.4, 3.1.5, 3.1.6 , 游戏过程中的数据需要以非常快的速度不断变化, 所以这些数据必须在内存中进行管理. 在内存中进行管理的关键是注意 CPU 频率, 也就是要在几纳秒至几百纳秒的延迟内访问数据, 而光 1 纳秒也就前进 30 厘米的距离.

也就是说, 游戏数据需要存放在距离 CPU 数十厘米以内的地方, 但是在实际中, 玩家通常分散在各处, 所以必然要在较远处和较近处之间冗余地保存数据, 以此保证数据的一致性, 这一点非常困难.

## 3.2 网络游戏特有的要素

### 3.2.1 通信延迟

### 3.2.2 带宽--传输量的标准

### 3.2.3 服务器--成本, 服务器数量的估算

### 3.2.4 安全性--网络游戏的弱点

### 3.2.5 辅助系统

## 3.3 物理架构详解

### 3.3.1 基本的网络拓扑结构

为了尽可能的降低通信延迟, 实际使用的有星型, 和全网状结构(full mesh).

### 3.3.2 物理架构的总类

### 3.3.3 C/S 架构--纯服务器型, 反射型

反射型只进行数据包的交换, 并不检查其中的内容.

### 3.3.4 P2P 架构

P2P 架构有同步和异步两种方式, 同步方式有全网状结构和星型结构两种.

### 3.3.5 C/S + P2P 混合型架构

### 3.3.6 ad-hoc 模式

## 3.4 逻辑架构详解

### 3.4.1 MO, MMO 是什么? -- 同时在线数的区别

### 3.4.2 MO 架构, MOG

MO 架构经常在 FPS 和 RTS 等类型的游戏中使用.

* MO 架构
  * 同步方式/全网状结构
  * 同步方式/星型结构
  * 异步方式/全网状结构
  * 异步方式/星型结构

### 3.4.3 同步方式--获得全体玩家的信息后, 游戏才能继续

### 3.4.4 同步方式/全网状结构的实现--所有终端都拥有主数据












