# 0 [快速入门]网络游戏编程

## 0.2 套接字编程入门--处理多个并发连接, 追求性能

### 0.2.6 单线程, 非阻塞, 事件驱动--使用 select 函数进行轮询

```c
int sock = socket(PF_INET, SOCK_STREAM);
bind(sock, addr);
listen(sock);

allsock.add(sock);
while (1) {
    result = select(sock);
    if(result > 0) {
        int new_sock = accept(sock, &addr);
        allsock.add(new_sock);
    }

    foreach(sock = allsock){
        result = select(sock);
        if(result > 0) {
            char buf[100];
            size_t size = read(new_sock, buf, 100);

            if(size == 0) {
                close(new_sock);
            } else {
                write(new_sock, buf, size);
            }
        }
    }
}
```

### 0.2.7 网络游戏输入输出的特点--单线程, 事件驱动, 非阻塞

### 0.2.9 充分发挥性能和提高开发效率--从实现语言到底层结构

软件性能与开发效率是矛盾的

C/C++ > java > 脚本语言

<p align="left"><font size=2>表 0.1 主要的编程语言与吞吐量</font></p>

| 语言 | 吞吐量 | 特性 |
| ------| ------ | ------ |
| C/C++ | 100 | 静态类型, 本地代码 |
| Java/C# | 1 ~ 10 | 静态类型, VM, 字节码 |
| Ruby/Python | 0.1 ~ 1 | 动态类型 |

对于 CPU 密集型应用程序, Java 的运行速度与 C 近似.
但是对于 IO 密集型应用程序, 因为 Java 虚拟机每次进行系统调用, 都会进行缓存溢出检查和异常对象处理, 所以运行速度比 C 慢上 10 倍左右.

动态类型语言则比 Java 更慢, 因为每次进行一些处理时, 对象调用的方法都可能会发生变化, 所以每次调用前都必须进行检查确认.

Go 语言是一种静态的, 本地执行的语言, 它具有垃圾回收机制, 程序员可以在代码的不同部分中选择类型化的强度.

### 0.2.10 发挥多核服务器的性能

在 Linux 上, 平均每个 CPU 内核一秒内可以执行 10 万~20 万次上下文切换.(这里的上下文切换指的是操作系统调度单元的切换)

### 0.2.12 简化服务器实现--libevent

libevent 单线程 + 事件驱动 + 非阻塞调用

libevent 最大的特点就是: 它的工作方式并非创建大量线程然会等待 read 等系统调用, 而是"不创建线程, 为每一个想要事先通知的事件注册回调函数, 当事件发生时, 只进行一次函数调用"

## 0.3 RPC指南--最简单的通信中间件

DSL(Domain Specific Language 领域特定语言)
IDL(Interface Description Language 接口描述语言)

Protocol Buffers
Thrift

### 0.4.4 游戏编程精粹--不使用线程的"任务系统"

游戏中的许多物体在同一时刻看上去都在各自运动, 但在系统中并没有用多个线程来并行处理.因此游戏一般是按帧来运算的, 用一个或几个定时循环的线程处理事件来表达场景中的所有物体.

### 2.5.2 网络游戏服务运营的3项专门职责

* 开发
* 运维
* 销售

## 2.7 支持网络游戏的技术的大类

<p align="left"><font size=2>表 2.2 物理结构上的分类及其性质上的差异</font></p>

|  | C/S | P2P |
| ------| ------ | ------ |
| 延迟(所需时间, 通信延迟) | 大 | 小 |
| 服务器设备成本 | 大 | 小 |
| 带宽成本 | 根据游戏内容决定 | 根据游戏内容决定 |
| 非法行为 | 困难 | 容易 |

MMO Massively Multiplayer Online
MO  Multi-player Online

<p align="left"><font size=2>表 2.3 逻辑结构上的分类及特征</font></p>

|  | MO | MMO |
| ------| ------ | ------ |
| 游戏核心 | 少量玩家聚集在一起竞赛 | 大量玩家进行社交活动 |
| 同时玩家数 | 20 左右 | 200~1000000 |
| 延迟 | 50 毫秒 | 300 毫秒 |
| 游戏时间(累积) | 几分钟 | 几年 |
| RMT(真实货币交易, Real Money Trading) | 很少 | 活跃 |
| 平台 | 游戏机 | PC, 移动设备 |

网络游戏的4种形式--物理结构 * 逻辑结构
物理结构有 C/S 和 P2P 两种, 逻辑结构有 MO 和 MMO 两种, 共有四种组合

<p align="left"><font size=2>表 2.4 网络游戏的4种形式及游戏类型</font></p>

|  | MO | MMO |
| ------| ------ | ------ |
| C/S | 休闲游戏 | MMORPG 虚拟世界 |
| P2P | ARPG(动作类 RPG), 对战格斗游戏, FPS, 竞速游戏, RTS, 射击游戏 | N/A |

### 2.8.2 支持网络游戏主体的3大核心

* 游戏的数据形式
* 游戏的通信方式
* 游戏的反应速度(延迟)

显示器每秒进行几十次的画面更新, 这种画面更新时间对玩家来说, 就是游戏状态变化的最短时间间隔

<p align="left"><font size=2>表 2.5 网络延迟与实现方法</font></p>

| 名称 | 延迟 | 同步/异步 | 冗长 | 补充 |
| ------| ------ | ------ |
| 同步方式 | 25毫秒以下 | 同步 | 非冗余 | 在高速网络的前提下, 同步方式的实现方法比较好 |
| 异步方式 | 100毫秒以下 | 非同步 | 冗余 | 为了在低速的网络上实现高速的游戏, 冗余性是必需的 |
| 浏览器方式 | 300毫秒以下 | 非同步 | 非冗余 | 延迟的程度超出了用冗余性可以解决的范围, 所以将游戏数据和游戏客户端(游戏浏览器)完全分离 |

同步方式是指, 运行在所有游戏玩家设备上的程序是同步的, 只要一个人的网络发生延迟, 后台程序的运行就会变慢, 所有人都会受影响.
异步方式是指, 各个终端上的游戏进行状态是异步的, 就算某台终端上的程序停止运行, 其他终端的程序也能照常运行, 但是会看到问题终端对应的角色出现卡死
浏览器方式是指所有游戏内容都运行在后来, 前台只起到显示的作用, 这样即使服务器以外的所有程序都停止运行, 程序也能继续运行, 不会发生数据不匹配.

* 游戏处理的冗余化 --> 解决主数据和副本数据之间的关系
* 游戏处理的异步化 --> 解决数据变化时同步处理(锁)和异步处理之间的关系

### 3.1.2 将数据存放在内存中的理由

### 3.1.3 每 16 毫秒变化一次--处理的信息及其大小

### 3.1.4 大量对象的显示--CPU 的处理能力

游戏是按帧来处理的, 假设 1 秒钟有 60 帧, CPU 的主频是 1.79 MHz, 那么对于每一帧游戏画面, CPU 大约有 3 万个时钟周期可用(1790000/60 = 29666).

要让游戏世界中的物体移动起来, 必须进行以下处理: 读取坐标, 读取速度, 进行计算, 保存结果. 使用 6502 处理器的命令集处理以上操作需要 2~8 个周期, 假设在效率较高的程序中需要 4 个周期, 而且游戏场景中有 8 个物体, 那么要对二维坐标中 X, Y 两个数据各处理一次, 总共需要 `(4 + 4 + 4 + 4) * 2 * 8 = 256` 个周期, 相对于 CPU 3 万周期的处理能力可谓十分充裕.

接着需要判断己方子弹是否击中了敌人, 假设要对正在飞行的 8 个物体全部进行碰撞检测, 那么就必须进行 `8 * 8 = 64` 次检测, 碰撞检测不能根据两个物体的坐标是否一致来进行判断, 而是必须通过矩形来判断, 所以需要进行二次比较. 因此处理过程如下: 读取坐标, 二次比较, 判断结果. 这次没想处理需要 10 个周期, 又因为要处理 X, Y 坐标, 所以还要翻一倍, 最终需要 `(10 + 10 + 10 + 10) * 2 * (8 * 8) = 5120` 个周期, 再加上移动处理的 256 个周期, 也就 5400 个周期不好, 看上去还挺宽裕的.

家用游戏机上的经典游戏通常有 20 个左右的角色登场. 若对 20 个对象进行碰撞检测, 根据上面的计算方式, 需要 `(10 + 10 + 10 + 10) * 2 * (20 * 20) = 32000` 个周期, 这样就超过了 3 万周期的上限. 另外这里还没有考虑其他操作以及声音处理, 因此必须采取一些优化措施来降低所消耗的周期, 比如, 把"己方子弹之间不会发生碰撞", "敌方子弹与己方子弹不会发生碰撞" 等游戏内容考虑在内.

当 CPU 运算能力不足时, 游戏画面的刷新率就会降低, 导致游戏中物体的运动变得迟缓, 导致游戏体验急剧下降.

* 假设在家用游戏机中使用 RDBMS, 那么就必须通过 SQL 语句, 但是像 SELECT * from FlyingObjects 这样的语句, 单单判断语法是否正确就要消耗几百个 CPU 周期, 显然不现实. 游戏编程必须在 1 帧内完成坐标的判断和保存. 为此, 必须只通过组合 CPU 所具有的一些最原始的命令来实现, 只是读取数据就要花费几百个周期是相当不合理的. 因此, 在家用游戏机中, 基本不考虑使用 RDBMS 这种方式.

### 3.1.5 无法预测玩家的操作--游戏状态千变万化(难以优化)

### 3.1.6 必须将游戏数据放在 CPU 所在的机器上

综合 3.1.4, 3.1.5, 3.1.6 , 游戏过程中的数据需要以非常快的速度不断变化, 所以这些数据必须在内存中进行管理. 在内存中进行管理的关键是注意 CPU 频率, 也就是要在几纳秒至几百纳秒的延迟内访问数据, 而光 1 纳秒也就前进 30 厘米的距离.

也就是说, 游戏数据需要存放在距离 CPU 数十厘米以内的地方, 但是在实际中, 玩家通常分散在各处, 所以必然要在较远处和较近处之间冗余地保存数据, 以此保证数据的一致性, 这一点非常困难.

## 3.2 网络游戏特有的要素

### 3.2.1 通信延迟

### 3.2.2 带宽--传输量的标准

### 3.2.3 服务器--成本, 服务器数量的估算

### 3.2.4 安全性--网络游戏的弱点

### 3.2.5 辅助系统

## 3.3 物理架构详解

### 3.3.1 基本的网络拓扑结构

为了尽可能的降低通信延迟, 实际使用的有星型, 和全网状结构(full mesh).

### 3.3.2 物理架构的总类

### 3.3.3 C/S 架构--纯服务器型, 反射型

反射型只进行数据包的交换, 并不检查其中的内容.

### 3.3.4 P2P 架构

P2P 架构有同步和异步两种方式, 同步方式有全网状结构和星型结构两种.

### 3.3.5 C/S + P2P 混合型架构

### 3.3.6 ad-hoc 模式

## 3.4 逻辑架构详解

### 3.4.1 MO, MMO 是什么? -- 同时在线数的区别

* MO(Multiplayer Online) 与 MMO(Massively Multiplayer Online) 的区别
MO 同时在线人数较少(2 - 100), 游戏时间相对较短, 没错开始游戏时, 游戏的状态都会被重置, 游戏数据的形式是一次性的.
MMO 同时在线数量达到数百或数千, 游戏数据不能重置, 且是永久性的.

### 3.4.2 MO 架构, MOG

MO 架构经常在 FPS 和 RTS 等类型的游戏中使用, 适合那些在线人数较少, 实时性很高的游戏.

* MO 架构
  * 同步方式/全网状结构
  * 同步方式/星型结构
  * 异步方式/全网状结构
  * 异步方式/星型结构

### 3.4.3 同步方式--获得全体玩家的信息后, 游戏才能继续

同步方式/全网状结构, 参与游戏的所有终端都拥有主数据, 这些终端互相传输所有的控制设备输入信息, 在获得所有终端的输入数据之前, 游戏始终处于等待状态.
同步方式/星型结构, 配置一个综合管理游戏数据的根服务器, 所有参与游戏的终端将玩家的所有输入信息发送至服务器, 游戏状态一旦有所进展, 服务器就将那些改变了的状态数据返回给所有客户端, 在服务器返回信息之前, 所有的客户端都不进行任何渲染, 只是单纯的等待.

### 3.4.4 同步方式/全网状结构的实现--所有终端都拥有主数据

各终端之间只发送 "控制设备的输入信息", 游戏过程数据都是数字数据, 所以如果能毫无遗漏的发送初始状态及状态变化, 所有玩家的状态就能始终保持一致.

例子: 在线围棋游戏

同步方式/全网状结构的三个问题:
1. 人数增加后, 收发信息的完整性极易崩溃, 特别是在网络不可靠的情况下
2. 最慢的终端会拖长整体的传输时间
3. 不能中途加入游戏

### 3.4.5 同步方式/星型结构--暂时将输入信息集中到服务器上

这种结构下, 网络中的所有成员并不是完全平等的, 星型结构的中央终端称为 "服务器", 其他终端则称为 "客户端". 客户端将控制设备上的方向键等输入信息发送至服务器, 服务器在接收完成后则将接收到的输入信息同时发送给所有客户端.

这种方式对数据传输链路的要求下降, 同时也引入了新的问题:
* 响应较慢(直连变成了转发).

同步方式不可避免的重大问题, 中途加入游戏会导致所有玩家暂时中断游戏, 因为新客户端需要获取状态数据. 解决方式是优先匹配物理位置相近的玩家(提高状态同步速度)或将游戏回合变短(不需要中途加入游戏).

### 3.4.6 异步方式--接受各终端上游戏状态的不一致

### 3.4.7 游戏世界的三大基本要素--自己, 对手, 环境--异步实现的指导方针

### 3.4.8 自己和对手--对战游戏和玩家之间往来数据的抽象程度

### 3.4.10 自己和环境--可使用物品的格斗游戏和互斥控制

### 3.4.11 互斥控制的实现--采用与同步方式类似的机制来实现异步方式

分布式一致性算法不适用与该场景, 因为这种算法需要多次往返传输信息, 而采用异步方式的网络游戏需要在几十毫秒的这段极短的时间内保证数据一致.

* 物品复制问题

### 3.4.12 状态会自动变化的环境--静态环境和动态环境

### 3.4.13 对手与环境的关系
相对与"自己和对手", "自己和环境"来说不太重要, 能省就省

## 3.5 逻辑架构详解--MMO 架构

MMO 架构就是"在大量玩家之间共享长期存在的游戏过程", 对于这种游戏来说, 玩家投入了大量时间, 因此游戏系统必须具有很高的可靠性. MMO 架构中, 对游戏过程的管理和保存全部都由数据中心负责, 由数据中心持续的将游戏结果发送至玩家终端.

* MMO 游戏的特点:
1. 玩家数据需要持久化
2. 玩家数据会随着时间累积
3. 支持大量玩家同时在线

* 浏览器方式, 同步方式和异步方式的差异
浏览器方式和同步方式的差异在于"传输的内容", 同步方式下收发的只有自己及其他玩家输入的信息, 而在浏览器方式下, 浏览器向服务器发送的是本地玩家的操作信息, 服务器向浏览器发送游戏世界中的结果.
此外, 在同步和异步方式下, 参与游戏的所有终端都共享游戏过程中的所有数据, 而在浏览器模式下, 管理游戏数据的只有服务器, 游戏逻辑全部都在服务器上实现, 各个终端(浏览器)只展现当前玩家操作在游戏世界中产生的结果.

* MMO 架构的实现方针--浏览器方式(这里的浏览器不是指 web 浏览器), 纯粹的 C/S 模式
1. 为了支持大量玩家同时在线, 必须使用异步的方式, 客户端与服务器的通信要考虑能够忍受较大通信延迟和不稳定的连接.
2. 客户端必须使用浏览器的方式实现, 只包含与渲染, 音效以及操作有关的处理, 将数据统一保存在服务器上, 从而避免大量玩家在线可能导致的巨量数据传输. 就算不启动客户端, 游戏也会在服务器上持续运行.

















