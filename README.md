# memo

---

## 算法

- [算法图示](http://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
- [算法学习笔记](https://brandeath.gitbooks.io/al/content/index.html)
- [Monte Carlo Tree Search – beginners guide](https://int8.io/monte-carlo-tree-search-beginners-guide/#more-2250)

---

## 云

- [Docker Doc](https://docs.docker.com/)
- [Cloud Design Pattern](https://www.gitbook.com/book/iambowen/cloud-design-pattern/details)

---

## 运维

- [集中式日志系统 ELK 协议栈详解](https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/  "Title")

---

## 大数据

- [数据处理平台架构中的SMACK组合：`Spark`、Mesos、Akka、Cassandra 以及 Kafka](http://blog.dataman-inc.com/untitled-23/  "Title")
- [Hadoop: The Definitive Guide, 4th Edition](http://javaarm.com/file/apache/Hadoop/books/Hadoop-The.Definitive.Guide_4.edition_a_Tom.White_April-2015.pdf)

---

## 机器学习

- [【机器学习笔记1】Logistic回归总结](http://blog.csdn.net/dongtingzhizi/article/details/15962797)
- [【机器学习笔记2】Linear Regression总结](http://blog.csdn.net/dongtingzhizi/article/details/16884215)
- [【机器学习笔记3】Stanford公开课Exercise 2——Linear Regression](http://blog.csdn.net/dongtingzhizi/article/details/16949755)
- [【机器学习笔记4】Stanford公开课Exercise 3——Multivariate Linear Regression](http://blog.csdn.net/dongtingzhizi/article/details/16979103)
- [卷积神经网络介绍](https://yjango.gitbooks.io/superorganism/content/juan-ji-shen-jing-wang-luo-2014-2014-jie-shao.html)
- [DeepLearningBook](https://github.com/HFTrader/DeepLearningBook)
- [monkeylearn](https://monkeylearn.com/)
- [The Neural Network Zoo](http://www.asimovinstitute.org/neural-network-zoo/)
- [马尔可夫链蒙特卡罗方法(MCMC)](http://www.cnblogs.com/pinard/p/6625739.html)

---

## 量化交易

- [Trading Systems: a new approach to system development and portfolio optimisation](http://jamescarl.github.io/CEN4020/assets/pdf/013.pdf)

---

## 论文

- [arxiv 论文下载网站](https://arxiv.org/)
- [Concurrent Programming for Scalable Web Architectures](https://github.com/tpn/pdfs/blob/master/Concurrent%20Programming%20for%20Scalable%20Web%20Architectures%20-%20Benjamin%20Erb%20-%20Thesis%20(April%202012)%20(vts_8082_11772).pdf)

---

## C++

- [Foundations of C++](http://www.stroustrup.com/ETAPS-corrected-draft.pdf)
- [cppreference.com](http://en.cppreference.com)
- [C++模板的偏特化与全特化](https://harttle.land/2015/10/03/cpp-template.html)
- [C++模板元编程](https://www.cnblogs.com/liangliangh/p/4219879.html)

---

## JAVA

- [servlet-3-1-specification](https://waylau.gitbooks.io/servlet-3-1-specification/)
- [spring-framework-4-reference](https://www.gitbook.com/book/waylau/spring-framework-4-reference/details)
- [Essential Netty in Action](https://www.gitbook.com/book/waylau/essential-netty-in-action/details)
- [OSGI specifications](https://www.osgi.org/developer/specifications/)
- [OSGI企业应用开发](http://blog.csdn.net/masusan/article/details/69951536)
- [OSGi的缘起缘灭](http://lanlingzi.cn/post/technical/2015/0422_remove_osgi/)
- [Java调优经验谈](http://www.rowkey.me/blog/2016/11/02/java-profile/)
- [成为JavaGC专家(1)-深入浅出Java垃圾回收机制](http://www.importnew.com/1993.html)
- [成为JavaGC专家(2)-如何监控Java垃圾回收机制](http://www.importnew.com/2057.html)
- [成为JavaGC专家(3)-如何优化Java垃圾回收机制](http://www.importnew.com/3146.html)
- [成为JavaGC专家(4)-Apache的MaxClients参数详解及其在Tomcat执行FullGC时的影响](http://www.importnew.com/3151.html)

---

## Protocol buffers

- [Protocol buffers](https://developers.google.com/protocol-buffers/)

---

## 技术Blog

- [martinfowler](https://martinfowler.com/)
- [张逸](http://zhangyi.farbox.com/)
- [阮一峰](http://www.ruanyifeng.com/blog/)
- [结构之法](http://blog.csdn.net/v_july_v) 专注算法、机器学习
- [王垠](http://www.yinwang.org/)
- [Trygve M. H. Reenskaug](http://heim.ifi.uio.no/~trygver/)

---

## 前端

- [redux 教程](http://cn.redux.js.org/)
- [AngularJS Guide](https://docs.angularjs.org/guide/)
- [AngularJS API](https://docs.angularjs.org/api)
- [ECMAScript 6 入门](http://es6.ruanyifeng.com/)

---

## trading ststem

- [trading ststem -Urban Jaekle](http://jamescarl.github.io/CEN4020/assets/pdf/013.pdf)

---

## 高性能服务器架构思路

- [高性能服务器架构思路：缓冲策略(一)](https://www.qcloud.com/community/article/164816001481011875?fromSource=gwzcw.59428.59428.59428)
- [高性能服务器架构思路：缓冲清理策略(二)](https://www.qcloud.com/community/article/164816001481011876?fromSource=gwzcw.59407.59407.59407)
- [高性能服务器架构思路：分布式系统概念(三)](https://www.qcloud.com/community/article/164816001481011877?fromSource=gwzcw.59429.59429.59429)
- [高性能服务器架构思路：编码复杂度和通信(四)](https://www.qcloud.com/community/article/164816001481011878?fromSource=gwzcw.59432.59432.59432)
- [高性能服务器架构思路：分布式缓存(五)](https://www.qcloud.com/community/article/164816001481011879?fromSource=gwzcw.59438.59438.59438)

---

## Linux

- [Linux进程描述符task_struct结构体详解](http://blog.csdn.net/gatieme/article/details/51383272)
- [进程间通信-创建管道实现机制](http://blog.csdn.net/tiankong_/article/details/76468140)
- [Linux 中的零拷贝技术, 第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/)
- [Linux 中的零拷贝技术, 第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/)
- [libevent深入浅出](https://www.gitbook.com/book/aceld/libevent)

---

## 书目

- Promise Theory Principles and Applications

---

## 其他

- [响应式编程](http://reactivex.io/)

---

## 设计模式

- [Domain-driven design](http://dddcommunity.org/)
- [图说设计模式](http://design-patterns.readthedocs.io)

---

## 数据结构

- [HashedWheelTimer](https://zacard.net/2016/12/02/netty-hashedwheeltimer/)

---

## java

### 关于final的知识点

- final 关键字可以用于成员变量, 本地变量, 方法以及类.
- final 成员变量必须在声明的时候初始化或者在构造器中初始化, 否则就会报编译错误.
- final 变量不能够再次赋值.
- 匿名内部类(定义在方法中的内部类)的参数必须是 final 变量. 内部类能访问外部方法中所有的局部变量, 但是局部变量生命周期与内部类的生命周期并非一致, 为了避免内部类对象访问一个已不存在的局部变量, 解决方法是将变量设置为 final, 复制一份直接作为局部内部中的数据成员(final 保证复制品与原始值一致), 当内部类访问局部变量时, 其实真正访问的是这个局部变量的"复制品", 因此当运行栈中的真正的局部变量死亡时, 局部内部类对象仍可以访问局部变量.
- final 关键字可以把方法锁定, 确保父类中的方法保持不变并不会被覆盖(重写).
- final 类不能被继承.
- final 关键字容易与 finalize() 方法搞混, 后者是在 Object 类中定义的方法, 是在垃圾回收之前被 JVM 调用的方法.
- 接口中声明的所有变量必须是 final 的.
- final 和 abstract 这两个关键字是互斥的, final 类就不可能是 abstract 的.
- final 方法在编译阶段绑定, 称为静态绑定(static binding).
- final 本地变量必须在声明时赋值.
- 没有在声明时初始化 final 变量的称为空白 final 变量(blank final variable), 它们必须在构造器中初始化, 或者调用 this()(调用本类中对应的构造函数, 通常为构造函数中的第一条语句) 初始化.不这么做的话，编译器会报错"final 变量(变量名)需要进行初始化".
- 将类, 方法, 变量声明为 final 能够提高性能, 这样 JVM 就有机会进行优化.
- 按照 Java 代码惯例, final 变量就是常量, 在系统中为宏变量, 编译的时候就已经分配好内存和值, 而且通常常量名要大写.
- 对于集合对象声明为 final 指的是引用不能被更改, 但是你可以向其中增加, 删除或者改变内容. 譬如:

``` java
private final List Loans = new ArrayList();
list.add(“home loan”);  //valid
list.add("personal loan"); //valid
loans = new Vector();  //not valid
```

### 抽象类和接口的区别

- 如果一个类没有包含足够多的信息来描述一个具体的对象, 这样的类就是抽象类.
- 抽象类在实际应用中, 更多的是因为类中有抽象方法. 抽象方法: 只声明, 不实现. 具体的实现由继承它的子类来实现. 实际点就是:被 abstract 修饰的方法, 只有方法名没有方法实现, 具体的实现要由子类实现. 方法名后面直接跟一个分号, 而不是花括号.
- 一个类中含有抽象方法(被 abstract 修饰), 那么这个类必须被声明为抽象类(被 abstract 修饰).
- 接口在 java 中是是抽象方法的集合, 接口中没有构造方式(因为接口不是类)
- 接口中的方法必须是抽象的(java8 中接口也通过 default 支持方法实现)
- 接口中除了static, final变量, 不能有其他变量
- 接口支持多继承(一个类可以实现多个接口, 一个子接口可以继承多个父接口)
- 抽象类中可以有已经实现了的方法, 接口则不行
- 抽象类的子类没有全部实现抽象方法, 则必须把自己也修饰成抽象类, 交给继承它的子类来完成实现.实现接口的类, 必须实现**接口中的所有方法**.
- 抽象类可以有构造器, 而接口不能有构造器.
- 抽象方法可以有 public, protected 和 default 这些修饰符, 接口方法默认修饰符是 public, 你不可以使用其它修饰符.
- 抽象方法比接口速度要快.
- **接口可以继承多个接口**.
- 接口中没有 this 指针, 没有构造函数, 不能拥有实例字段(实例变量)或实例方法, 无法保存状态(state), 抽象方法中可以.
- 从设计理念上, 接口反映的是 "like-a" 关系, 抽象类反映的是 "is-a" 关系.
- 除了默认方法, Java 8 还在允许在接口中定义静态方法.
- 接口中的静态方法必须是 public 的, public 修饰符可以省略, static 修饰符不能省略.

### 泛型

- 定义泛型的时候使用 SomeName<T>, 对已经定义的泛型, 我们不想给她一个具体的类型做为类型参数, 我们可以给她一个不确定的类型作为参数 SomeName<?>
- 在定义泛型类时, 任意一个大写字母都可以, 但为了提高可读性，大家还是用有意义的字母比较好，一般来讲，在不同的情境下使用的字母意义如下:
  E    — Element, 常用在 java Collection 里, 如: List<E>, Iterator<E>, Set<E>
  K, V — Ke, Value, 代表 Map 的键值对
  N    — Number, 数字
  T    — Type, 类型, 如 String, Integer 等等
- Java 支持泛型类和泛型函数, 函数返回值如果是泛型, 函数定义时在返回值前加上<T>标识泛型
- static 方法无法访问泛型类的类型参数, 若要 static 方法支持泛型参数, 必须使其成为泛型方法
- Class<T> 和 Class<?> 代表 T 所对应的类
- <? extends T> 受限通配, 表示 T 的一个未知子类
- <? super  T> 受限通配, 表示 T 的一个未知父类
- Class<T> 的完整定义为：
  public final class Class<T> extends Object implements Serializable, GenericDeclaration, Type, AnnotatedElement
  Class 类的实例表示正在运行的 Java 应用程序中的类和接口, 枚举是一种类, 注释是一种接口.

### Java 编码注意事项

- Java 在构造子类的时候, 会先构造父类.
- 在 Java 中, 构造方法无法被继承, 但是可以被重载, 同时类无法设置默认构造方法(如果不实现类的构造方法, 会添加默认构造方法, 如果实现了则不添加).
- Jboss 同时是 Web 容器和 EJB 容器. Tomcat 只是Web容器.
- HashMap 几乎可以等价于 Hashtable, 除了 HashMap 是非 synchronized 的, 并可以接受null(HashMap 可以接受为null的键值(key)和值(value), 而 Hashtable 则不行).
- HashMap 是非 synchronized, 而 Hashtable 是 synchronized, 这意味着 Hashtable 是线程安全的, 多个线程可以共享一个 Hashtable; 而如果没有正确的同步机制的话, 多个线程是不能共享 HashMap 的.
- 对于 volatile 变量, 写此类变量的时候会强制把将线程本地内存的数据刷新到主内存上, 读取的时候会将主内存的数据加载到本地内存里, 在线程间保证状态的一致性.
- [AtomicIntegerFieldUpdater使用](http://www.cnblogs.com/hithlb/p/4516078.html)
- 容器中 entry 的删除要使用迭代器.
- 一个类不想要外界创建其对象时, 可以将父类的构造函数私有化, 本类中提供返回对象的方法, 并且多数情况下提供的对象是唯一的,单例设计模式就是一个很好的例子,而当我们开发中需要保证对象唯一性的时候, 往往就采取这种做法.
- 未初始化的 int 类型类变量默认值为 0.
- 构造代码块的作用是给对象进行初始化, 有对象建立, 才会运行构造代码块, 且优先于构造函数执行, 构造代码块中定义的是不同对象共性的初始化内容.
- 静态代码块随着类的加载而执行, 只执行一次, 并优先于主函数, 静态代码块其实就是给类初始化的, 而构造代码块是给对象初始化的, 静态代码块中的变量是局部变量, 与普通函数中的局部变量性质没有区别, 一个类中可以有多个静态代码块.
- Java 类初始化顺序:
  ![Java类初始化顺序](https://raw.githubusercontent.com/21moons/memo/master/res/img/java/Java类初始化顺序.png)

  1. 访问SubClass.main(),(这是一个 static 方法), 于是装载器就会为你寻找已经编译的 SubClass 类的代码(也就是 SubClass.class 文件). 在装载的过程中, 装载器注意到它有一个基类(也就是 extends 所要表示的意思), 于是它再装载基类. 不管你创不创建基类对象, 这个过程总会发生. 如果基类还有基类, 那么第二个基类也会被装载, 依此类推.
  2. 执行根基类的 static 初始化, 然后是下一个派生类的 static 初始化, 依此类推. 这个顺序非常重要, 因为派生类的 "static 初始化" 有可能要依赖基类成员的正确初始化.
  3. 当所有必要的类都已经装载结束, 开始执行 main() 方法体, 并用 new SubClass() 创建对象.
  4. 类 SubClass 存在父类, 则调用父类的构造函数, 你可以使用 super 来指定调用哪个构造函数. 基类的构造过程以及构造顺序, 同派生类的相同. 首先基类中各个变量按照字面顺序进行初始化, 然后执行基类的构造函数的其余部分.
  5. 对子类成员数据按照它们声明的顺序初始化, 执行子类构造函数的其余部分.
- 为了避免父类的构造函数调用子类的多态方法, 一般可以将父类的同名函数声明为 private, 这样在父类构造函数中调用的就是自己的方法.

  ```java
  public class Test1 {
      public static void main(String[] args) {
          A b = new B();
          b.print();
      }
  }
  
  class A {
      public A(){
          print();
      }
  
      public void print(){
          System.out.println("A");
      }
  }
  class B extends A{
      int i = 1;
      public B(){
          print();
      }
  
      public void print(){
          System.out.println("B" + i);
      }
  }
  ```

---

## docker

- docker 要求必须部署在64位机器上
- 容器内的数据是临时性的, 它会随着容器生命周期的结束而消失
- 默认的 Docker volume （driver = ‘loclal’）不管是哪种形式, 本质上都是将容器所在的主机上的一个目录 mount 到容器内的一个目录, 因此, 它不具备可移植性.

---

## 英文缩写

- TOE(TCP Offload Engine)
  TOE 技术, 即利用网卡上的专用处理器完成数据包的处理任务. 将用户数据直接拷贝到数据链路层, 通过 TOE 网卡驱动处理, 减少了传输层与网络层的数据拷贝, 降低了 CPU 负载, 在加快网络传输速度和网络响应的同时提高设备性能.

---

## [Is there a difference between fibers, coroutines and green threads](https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i)

A Fiber is a lightweight thread that uses cooperative multitasking instead of preemptive multitasking. A running fiber must explicitly "yield" to allow another fiber to run, which makes their implementation much easier than kernel or user threads.

A Coroutine is a component that generalizes a subroutine to allow multiple entry points for suspending and resuming execution at certain locations. Unlike subroutines, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine.

A Green Thread is a thread that is scheduled by a virtual machine (VM) instead of natively by the underlying operating system. Green threads emulate multithreaded environments without relying on any native OS capabilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support.