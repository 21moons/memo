# 基础

---------------------

## 1 导论

### 1.1 典型游戏团队的结构

* 工程师
  * 运行时程序员
  * 工具程序员
* 艺术家
  * 概念艺术家(concept artist)
  * 三维建模师(3D modeler)
  * 纹理艺术家(texture artist)
  * 灯光师(lighting artist)
  * 动画师(animator)
  * 动画捕捉演员(motion capture actor)
  * 音效设计师(sound designer)
  * 配音演员(voice actor)
  * 作曲家(composer)
* 游戏设计师(game designer)
* 制作人(producer)

### 1.3 游戏引擎是什么

大部分游戏引擎是针对特定游戏及特定硬件平台所精心制作及微调的. 就算是一些最通用的游戏引擎, 其实也只适合制作某类型游戏. 游戏引擎或中间件组件越通用, 在特定平台运行特定游戏的性能就越一般.

出现这种现象, 是因为设计高效的软件总是需要取舍

### 1.6 运行时引擎架构

如同所有软件系统, 游戏引擎也是以软件层(software layer)构建的. 通常上层依赖下层, 下层不依赖上层. 当下层依赖上层时, 称为循环依赖(circular dependency). 在任何软件中, 循环依赖都要极力避免, 不然会导致系统间复杂的耦合(coupling), 也会使软件难以测试, 并妨碍代码重用.

## 3 游戏软件工程基础

### 3.1 重温 C++ 及最佳实践

* 菱形继承问题(diamond problem)

在菱形继承问题中, 一个派生类最终包含了两份祖父类. C++ 可以使用虚继承(virtual inheritance) 去掉重复祖父类的数据.

![菱形继承](https://raw.githubusercontent.com/21moons/memo/master/res/img/game_engine_architecture/菱形继承.png)

大多数 C++ 软件开发者都会完全避免使用多重继承, 或只容许有限制的使用. 常见的惯例是, 只容许从一个单继承层次结构中多重继承一些简单且无父的类. 这些类有时被称为`嵌入类`(mix-in class), 因为它可在类树中任何位置加入新功能. 