# 可理解的一致性算法研究(raft)
> In search of an Understandable Consensus Algorithm (Extended Version)

## 摘要

Raft 是一种用来管理日志复制的一致性算法. 它与 Paxos 是等效的, 同时在性能上也相近,但是它采用了不同的结构;这使得 Raft 更容易理解, 也更易于建立实际的系统。为了便于理解，Raft 将一致性算法分为了几个部分，例如领导选取 (leader selection)，日志复制(log replication) 和安全性 (safety), 同时它**使用了更强的一致性来减少了必须需要考虑的状态**。从用户学习的结果来看, Raft 比 Paxos 更容易上手. Raft 还引入了一种新的机制动态改变集群成员，它使用**重叠大多数(overlapping majorities)**来保证安全。


## 1 介绍

一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器失效也能正常提供服务.正是因为这样的特点，他们在构建大规模可靠的软件系统中扮演了关键角色。在过去的数十年中 , Paxos 统治着有关一致性算法的讨论: 大多数一致性算法的实现都基于它或者受它影响, 并且 Paxos 也成了教授一致性知识的主要载体.

不幸的是, 尽管在降低它的复杂性方面做了许多努力, Paxos 依旧很难理解. 并且, Paxos 需要经过复杂的修改才能应用于实际系统. 这些导致了系统构建者和学生都十分头疼.

在被 Paxos 折磨之后， 我们开始寻找一种在系统构建和教学上表现更好的一致性算法. 我们的首要目标是让它易于理解: 我们能不能定义一种面向实际系统并且比 Paxos 更容易学习的的一致性算法呢? 并且, 我们希望这种算法能凭直觉就能明白, 这对于一个系统构建者来说是十分必要的. 让一个算法工作起来很重要, 知道它是如何工作的更重要.

我们工作的结果是一种新的一致性算法, 叫做 Raft. 在设计 Raft 的过程中我们应用了许多专门的技巧来使其便于理解, 包括算法分解(分为领导选取--leader selection, 日志复制--log replication 和安全性--safety) 和状态空间减少(state space reduction) (相对于 Paxos, Raft 减少了不确定性和服务器之间状态不一致的可能). 一项在两所学校的43个学生中进行的研究表明, Raft 比 Paxos 明显要更容易理解:在学习了两种算法之后, 其中的33个学生能够更好的回答 Raft 的问题.

Raft 算法和已有的算法在某些地方很相似(主要是 Oki 和 Liskov 的 Viewstamped Replication).但是 Raft 有几个新的特性：

*    强领导 (Strong Leader): Raft 强化了领导的作用. 例如, 日志条目只从领导者发往其他服务器. 这样就简化了对日志复制的管理, 使得 Raft 更易于理解.
*    领导选取 (Leader Selection): Raft 使用随机定时器来选取领导者. 这种方法仅仅是在所有一致性算法都需要的心跳机制上增加了一点变化，然而它却使得解决冲突更简单和快速。
*   成员变化 (Membership Change): Raft 为了调整集群中成员使用了新的**联合一致性(joint consensus)的方法, 这种方法中大多数不同配置的机器在转换关系的时候会交迭(overlap).** 这使得在配置改变的时候, 集群仍然能够正常运作.

我们认为, raft 在教学和实际应用方面比 Paxos 和其他算法表现更好. 它比其他算法更简单, 更容易理解；它满足一个实际系统的所有需求；它拥有许多开源的实现并且被许多公司使用；它的安全性已经被证实；并且它的效率也具有竞争力。

这篇论文剩下的部分会讲如下内容：复制状态机 (replicated state machine) 问题 (第2节), 讨论 Paxos 的优缺点(第3节), 描述我们对可理解性的一般方法(第4节), 陈述 Raft 一致性算法(第5~8节), 评价 Raft 算法(第9节), 对相关工作的讨论(第10节).


## 2 复制状态机 (Replicated State Machine)

一致性算法是在复制状态机的背景下提出来的. 在这个方法中，一组服务器中的所有状态机计算并获取同样的状态, 即使有一些服务器崩溃了, 这组服务器(作为一个整体)仍然能继续运行. 复制状态机在分布式系统中被用于解决许多容错问题, 例如 GFS, HDFS 还有 RAMCloud 这些大规模的系统都有一个单独的集群领导，通常用一个单独的复制状态机来进行领导选取和存储配置信息来应对领导者的崩溃. 使用复制状态机的例子包括 Chubby 和 ZooKeeper.

![Replicated State Machine](https://raw.githubusercontent.com/21moons/memo/master/res/img/raft_1.jpg)

<font size=2>图1: 复制状态机的架构。一致性算法管理复制日志, 它包括来自客户的状态机命令。所有的状态机都处理相同的命令序列，因此会得到相同的执行结果</font>

如图-1所示，复制状态机是通过复制日志来实现的。每台服务器保存的日志都是相同的，日志中包含一系列的命令，状态机会执行相同顺序的命令。因为每一台计算机的状态机都是确定的(唯一的输入对应唯一的输出)，所以所有的状态机都次都会计算出相同的状态，并最终得到相同的结果.

一致性算法的工作是保证复制日志一致. 服务器上的一致性模块接受客户端的命令并将命令加入复制日志. 它和其他服务器上的一致性模块进行通信来确保每一个日志最终包含相同的请求序列, 即使有一些服务器宕机. 一旦这些命令被正确的复制了, 每一个服务器的状态机都会按同样的顺序去执行它们, 然后将结果返回给客户端. 最终, 这些服务器看起来就像一台高可靠的状态机.

应用于实际系统的一致性算法一般有以下特性:


* 确保安全性(从来不会返回一个错误的结果), 即使在所有的非拜占庭(Non-Byzantine)情况下, 包括网络延迟、分区、丢包、冗余和乱序。
* 高可用性，只要集群中的大部分机器能运行，可以互相通信并且与客户端通信，这个集群就可用。因此，一个拥有 5 台机器的集群可以容忍其中任意 2 台机器的失败(fail)。服务器停止工作了我们就认为它失败(fail)了，没准一会当它们拥有稳定的存储时就能从中恢复过来，重新加入到集群中。
* 不依赖时序保证一致性，时钟错误和极端情况下的消息延迟在最坏的情况下才会引起可用性问题。
* 通常情况下，一条命令能够在大多数节点对远程调用作出响应时就完成，少部分慢的机器不会影响系统的整体性能。


## 3 Paxos 算法的不足

在过去的10年中, Leslie Lamport 的 Paxos 算法几乎已经成为了一致性算法的代名词:它是授课中最常见的算法, 同时也是许多其他一致性算法实现的源头.Paxos 首先定义了一个能够达成单一决策一致的协议，例如一个单一复制日志条目(single replicated log entry). 我们把这个子集叫做单一决策 Paxos(single-decree Paxos).之后 Paxos通过组合多个这种协议来完成一系列的决策，例如一个日志（multi-Paxos).Paxos 确保安全性和活跃性(liveness), 并且它支持集群成员的变更. 它的正确性已经被证明, 通常情况下也很高效.

不幸的是, Paxos 有两个致命的缺点. 第一个是 Paxos 太难以理解. 它的完整解释晦涩难懂;很少有人能完全理解, 只有少数人成功的读懂了它. 因此大家尝试用一些简单的术语来描述它. 尽管这些解释都专注于单一决策问题, 但仍具有挑战性. 在 NSDI 2012 会议上的一次非正式调查显示, 我们发现大家对 Paxos 都感到不满意, 其中甚至包括一些有经验的研究员. 我们自己也曾深陷其中, 我们在读了几篇简化版的说明文档并且设计了我们自己的算法之后才完全理解了 Paxos, 而整个过程花费了将近一年的时间.

我们假定 Paxos 的晦涩是因为它将单一决策方案作为它的基础. 单一决策(Single-decree Paxos) 是晦涩且微妙的: 它被划分为两个没有简单直观解释的阶段，并且难以独立理解. 正因为如此, 它不能很直观的让我们知道为什么单一决策协议能够工作. 为多决策 Paxos 添加的规则又添加了额外的复杂性和精巧性.我们相信多次决策达成一致的问题能够分解为其它更直观的方式.

Paxos 的第二个缺点是它难以在实际环境中实现. 其中一个原因是, 对于多决策 Paxos (multi-Paxos)算法, 大家还没有达成广泛的一致. Lamport 的描述大部分都是有关于单一决策 Paxos (single-decree Paxos); 他仅仅描述了实现多决策的可能的方法, 但缺少许多细节. 有许多实现 Paxos 和优化 Paxos 的尝试, 但是他们都和 Lamport 的描述有些出入, 并且彼此也没有多少相同之处. 例如,Chubby 实现的是一个类似 Paxos 的算法, 但是在许多场景下的处理细节没有公开.

另外, Paxos 的架构对于实际实现来说也是不够的, 这是单一决策问题分解带来的又一个问题. 例如, 选择独立的日志条目集合然后将它们合并到顺序日志中没有什么好处, 它仅仅增加了复杂性. 相比之下, 围绕着日志来设计一个系统是更简单、更高效的: 新日志按照严格的顺序添加到日志中去. 另一个问题是, Paxos 使用对等的点对点方法作为它的核心(尽管它最终提出了一种弱领导者的形式来优化性能). 这种方法在只有一个决策被制定的情况下才有意义, 但是很少有现实中的系统使用这种方法. 如果要做一系列决策, 先选择一个领导人, 再由领导人来协调是更简单有效的方法.

因此, 实际系统中的一致性算法实现和 Paxos 算法都相差很大. 所有基于 Paxos 的实现都会遇到很多问题, 然后由此衍生出了许多与 Paxos 差异巨大的架构. 这是耗时且容易出错的, 理解Paxos的困难又加剧了问题. Paxos 算法在逻辑上是完备的, 但是实现上的困难使其理论上的完美毫无价值. 来自 Chubby 实现者的以下评论非常具有代表性:

> Paxos 算法的描述与实际实现之间存在巨大的鸿沟…最终的系统往往建立在一个没有被证明的算法之上.

正因为存在这些问题, 我们认为 Paxos 不仅对于系统的构建者来说不友好, 同时也不利于教学. 鉴于一致性算法对于大规模软件系统的重要性, 我们决定试着来设计一种比 Paxos 更好的一致性算法. Raft 就是这次尝试的结果.

## 4 易于理解的设计

Raft 需要达成以下几个目标：

* 它必须为系统构建提供一个详细的、可行的基础，这样便可以大量减少开发者的设计工作;
* 它必须在所有情况下都能保证安全,在典型的应用场景下保证可用;
* 它对于常规操作必须高效;
* 最重要的目标是：易于理解，它必须使得大多数人能够很容易的理解;
* 另外，它能让开发者有一个直观的认识，这样才能使系统构建者们去对它进行扩展, 而这种扩展是不可避免的.

在设计 Raft 的过程中, 我们不得不在许多点中做出选择. 当面临这种情况时，我们通常会基于可理解性进行权衡: 每种方法的可理解性是如何的?(例如，它的状态空间有多复杂?它是不是有很微妙的影响?)它的可读性如何?读者理解方法和它的含义是否容易?

我们意识到对这种可理解性的分析具有高度的主观性; 尽管如此, 我们使用了两种可以接受的方式. 第一种是众所周知的问题分解: 我们尽可能将问题分解成为若干个互不依赖的, 可解决的, 可被理解的小问题. 例如, 在 Raft 中, 我们把问题分解成为了**领导选取(leader election)**、**日志复制(log replication)**、**安全(safety)**和**成员变化(membership changes)**.

我们采用的第二个方法是通过减少需要考虑的状态的数量, 将状态空间简化, 这能够使得整个系统更加连贯一致, 消除可能的不确定性. Raft 明确定义日志之间不允许出现空洞，并且限制了日志不一致的可能性。尽管在大多数情况下, 我们都在试图消除不确定性, 但是有些情况下不确定性却使算法更易理解. 特别是, 随机化方法引入不确定性, 但是它通过以相似的方式处理所有可能的选择来减少状态空间(choose any; it doesn’t matter). 我们使用随机化来简化 Raft 中的领导选取算法.


## 5 Raft 一致性算法

Raft 是一种用来管理第 2 章中提到的复制日志的算法. **图-2** 是一个算法的总结版本,方便大家参考. **图-3** 列举了算法中的关键性质; 表格中的这些元素将会在这一章剩下的部分中分别进行讨论.

Raft 首先选出一个领导人, 然后给予领导人全权管理复制日志(replicated log)的权限, 这样来实现一致性. 领导人接收来自客户端的日志条目, 并把它们复制到其他的服务器上, 同时领导人还要告诉服务器们什么时候将日志条目应用到它们的状态机是安全的. 通过选出领导人能够简化复制日志的管理工作. 例如, 领导人能够自主决定将新的日志条目放到哪, 数据流只从领导人流向其他服务器. 如果领导人宕机或者和其他服务器失去连接, 下一个领导人将被选出.

通过领导人机制, Raft 将一致性问题分解成为三个相对独立的子问题: 

* 领导人选取(Leader election): 在一个领导人宕机之后必须要选取一个新的领导人(**5.2节**)
* 日志复制(Log replication): 领导人必须从客户端接收日志然后复制到集群中的其他服务器, 并且强制其他服务器的日志保持和自己相同
* **安全性(Safety)**: Raft 的关键安全特性是 **图-3** 中提到的状态机安全特性(State Machine Safety Property): 如果一个服务器已经将指定日志条目应用于状态机, 则所有其他服务器不会在该索引位置应用其他的指令(日志是全局的, 并且有唯一索引, 如果该索引位置已经有对应的日志, 那么任意机器不能覆盖). **5.4节** 阐述了 Raft 是如何保证这个特性的, 解决方案包括一个额外的选举约束, 这一部分会在 **5.2节** 中说明.

在说明了一致性算法之后, 本章会讨论有关可用性(availability)的问题和系统中时序(timing)的作用.

**状态：**

在所有服务器上持久存在的:(在响应远程过程调用 RPC 之前稳定存储的)

| 名称          | 描述                                                         |
| ------------ |:------------------------------------------------------------:|
| currentTerm  | 服务器最后知道的任期号(从0开始递增)                             |
| votedFor     | 在当前任期内收到选票的候选人 id(如果没有就为 null)               |
| log[]        | 日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号 |

<br>
<br>
在所有服务器上不稳定存在的：

| 名称          | 描述                                                         |
| ------------ |:------------------------------------------------------------:|
| commitIndex  | 已知的被提交的最大日志条目的索引值(从0开始递增)                             |
| lastApplied     | 被状态机执行的最大日志条目的索引值(从0开始递增)               |
<br>
<br>
在领导人服务器上不稳定存在的: (在选举之后初始化的)

| 名称          | 描述                                                         |
| ------------ |:------------------------------------------------------------:|
| nextIndex[]  | 对于每一个服务器，记录需要发给它的下一个日志条目的索引(初始化为领导人上一条日志的索引值+1)                             |
| matchIndex[]     | 对于每一个服务器，记录已经复制到该服务器的日志的最高索引值(从0开始递增)               |

<font size=2>表-2-i</font>

### 5.1 Raft 基础

一个 Raft 集群包括若干服务器; 对于一个典型的 5 服务器集群, 该集群能够在 2 台机器失效的情况下保持集群正常运行. 在任意的时间, 服务器一定会处于以下三种状态中的一个: 领导人, 候选人, 追随者. 在正常情况下, 只有一个服务器是领导人, 剩下的所有服务器都是追随者. 追随者们是被动的: 他们不会发送任何请求, 只是响应来自领导人和候选人的请求. 领导人来处理所有来自客户端的请求(如果一个客户端与追随者进行通信，追随者会将信息转发给领导人). 候选人用来选出领导人, 选举的细节会在 **5.2节** 进行阐释.**图-4** 阐述了这些状态和它们之间的转换; 转换随后将进行讨论.

如 **图-5** 所示，Raft 算法将时间划分成为任意不同长度的任期(term). 任期用连续的数字进行标识. 每一个任期都从选举(election)开始, 像 **5.2节** 所描述的那样, 一个或多个候选人会试图成为领导人. 如果一个候选人赢得了选举, 它就会在该任期的剩余时间担任领导人. 在某些情况下, 选票被平分, 有导致没有选出领导人, 那么, 将会开始另一个任期, 并且立刻开始下一次选举. Raft 算法保证在给定的任期内最多有一个领导人.

不同的服务器可能会在任期内观察到多次不同的状态转换，在某些情况下，一台服务器可能看不到一次选举或者一个完整的任期。任期在 Raft 中充当逻辑时钟的角色，并且它们允许服务器检测过期的信息，比如过时的领导人。每一台服务器都存储着一个当前任期的数字，这个数字会单调的增加。当服务器之间进行通信时，会互相交换当前任期号；如果一台服务器的当前任期号比其它服务器的小，则更新为较大的任期号。如果一个候选人或者领导人意识到它的任期号过时了，它会立刻转换为追随者状态。如果一台服务器收到的请求的任期号是过时的，那么它会拒绝此次请求。

Raft 中的服务器通过远程过程调用(RPC)来通信, 基本的 Raft 一致性算法仅需要 2 种 RPC. RequestVote RPC 是候选人在选举过程中触发的(5.2节), AppendEntries RPC 是领导人触发的, 为的是复制日志条目和提供一种心跳(heartbeat)机制(5.3节). 第7章加入了第三种 RPC 来在各个服务器之间传输快照(snapshot). 如果服务器没有及时收到 RPC 的响应, 它们会重试, 并且它们能够并行的发出 RPC 来获得最好的性能. 


### 5.2 领导人选举

Raft 使用一种心跳机制(heartbeat)来触发领导人的选取. 当服务器启动时, 它们会初始化为追随者. 一太服务器会一直保持追随者的状态只要它们能够收到来自领导人或者候选人的有效 RPC. 领导人会向所有追随者周期性发送心跳(heartbeat, 不带有任何日志条目的 AppendEntries RPC)来保证它们的领导人地位. 如果一个追随者在一个周期内没有收到心跳信息, 就叫做选举超时(election timeout), 然后它就会假定没有可用的领导人并且开始一次选举来选出一个新的领导人.

为了开始选举, 一个追随者会自增它的当前任期并且转换状态为候选人. 然后, 它会给自己投票并且给集群中的其他服务器发送 RequestVote RPC. 一个候选人会一直处于该状态, 直到下列三种情形之一发生:

* 它赢得了选举;
* 另一台服务器赢得了选举;
* 一段时间后没有任何一台服务器赢得了选举

这些情形会在下面的章节中分别讨论.

一个候选人如果在一个任期内收到了来自集群中大多数服务器的投票就会赢得选举. 在一个任期内, 一台服务器最多能给一个候选人投票, 按照先到先服务原则(first-come-first-served)(注意: 在 **5.4节** 针对投票添加了一个额外的限制). 大多数原则使得在一个任期内最多有一个候选人能赢得选举(**表-3** 中提到的选举安全原则). 一旦有一个候选人赢得了选举, 它就会成为领导人. 然后它会像其他服务器发送心跳信息来建立自己的领导地位并且组织新的选举.

当一个候选人等待别人的选票时, 它有可能会收到来自其他服务器发来的声明其为领导人的 AppendEntries RPC. 如果这个领导人的任期(包含在它的 RPC 中)比当前候选人的当前任期要大, 则候选人认为该领导人合法, 并且转换自己的状态为追随者. 如果在这个 RPC 中的任期小于候选人的当前任期, 则候选人会拒绝此次 RPC, 继续保持候选人状态.

第三种情形是一个候选人既没有赢得选举也没有输掉选举: 如果许多追随者在同一时刻都成为了候选人, 选票会被分散, 可能没有候选人能获得大多数的选票. 当这种情形发生时, 每一个候选人都会超时, 并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举. 然而, 如果没有其它手段来分配选票的话, 这种情形可能会无限的重复下去.

Raft 使用随机的选举超时时间来确保第三种情形很少发生, 并且能够快速解决. 为了防止在一开始是选票就被瓜分, 选举超时时间是在一个固定的间隔内随机选出来的(例如，150~300ms). 这种机制使得在大多数情况下只有一个服务器会率先超时, 它会在其它服务器超时之前赢得选举并且向其它服务器发送心跳信息. 同样的机制被用于选票一开始被瓜分的情况下. 每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间, 在超时进行下一次选举之前一直等待. 这能够减小在新的选举中一开始选票就被瓜分的可能性. **9.3节** 展示了这种方法能够快速的选出一个领导人。

选举是一个理解性引导我们设计替代算法的一个例子. 最开始时, 我们计划使用一种排名系统: 给每一个候选人分配一个唯一的排名, 用于在竞争的候选人之中选择领导人. 如果一个候选人发现了另一个比它排名高的候选人, 那么它会回到追随者的状态, 这样排名高的候选人会很容易地赢得选举. 但是我们发现这种方法在可用性方面有一点问题(一个低排名的服务器在高排名的服务器宕机后, 需要等待超时才能再次成为候选人, 但是如果它这么做的太快, 它能重置选举领带人的过程). 我们对这个算法做了多次调整, 但是每次调整后都会出现一些新的问题. 最终我们认为随机重试的方法是更明确并且更易于理解的.

### 5.3 日志复制

一旦选出了领导人, 它就开始接收客户端的请求. 每一个客户端请求都包含一条需要被复制状态机(replicated state machine)执行的命令. 领导人把这条命令作为新的日志条目加入到它的日志中去, 然后并行的向其他服务器发起 AppendEntries RPC, 要求其它服务器复制这个条目. 当这个条目被安全的复制之后(下面的部分会详细阐述), 领导人会将这个条目应用到它的状态机中并且会向客户端返回执行结果. 如果追随者崩溃了或者运行缓慢或者是网络丢包了, 领导人会无限的重试 AppendEntries RPC(甚至在它向客户端响应之后)知道所有的追随者最终存储了所有的日志条目.

日志就像 **图-6** 所示那样组织的. 每个日志条目存储着一条被状态机执行的命令和当这条日志条目被领导人接收时的任期号. 日志条目中的任期号用来检测在不同服务器上日志的不一致性, 并且能确保 **图-3** 中的一些特性. 每个日志条目也包含一个整数索引来表示它在日志中的位置.

领导人决定什么时候将日志条目应用到状态机是安全的; 这种条目被称为可被提交(commited).Raft 保证可被提交(commited)的日志条目是持久化的并且最终会被所有可用的状态机执行. 一旦被领导人创建的条目已经复制到了大多数的服务器上, 这个条目就称为可被提交的(例如，**图-6**中的7号条目). 领导人日志中之前的条目都是可被提交的(commited), 包括由之前的领导人创建的条目.**5.4**节将会讨论当领导人更替之后这条规则的应用问题的细节, 并且也讨论了这种提交方式是安全的. 领导人跟踪记录它所知道的被提交条目的最大索引值, 并且这个索引值会包含在之后的 AppendEntries RPC 中(包括心跳 heartbeat 中), 为的是让其他服务器都知道这条条目已经提交. 一旦一个追随者知道了一个日志条目已经被提交, 它会将该条目应用至本地的状态机(按照日志顺序).

我们设计了 Raft 日志机制来保证不同服务器上日志的一致性. 这样做不仅简化了系统的行为使得它更可预测, 并且也是保证安全性不可或缺的一部分.Raft 保证以下特性, 并且也保证了 **表-3** 中的日志匹配原则(Log Matching Property):

* 如果在不同日志中的两个条目有着相同的索引和任期号, 则它们所存储的命令是相同的.
* 如果在不同日志中的两个条目有着相同的索引和任期号, 则它们之间的所有条目都是完全一样的.

第一条特性源于领导人在一个任期里在给定的一个日志索引位置最多创建一条日志条目, 同时该条目在日志中的位置也从来不会改变. 第二条特性源于 AppendEntries 的一个简单的一致性检查. 当发送一个 AppendEntries RPC 时, 领导人会把新日志条目紧接着之前的条目的索引位置和任期号都包含在里面.如果追随者没有在它的日志中找到相同索引和任期号的日志, 它就会拒绝新的日志条目. 这个一致性检查就像一个归纳步骤: 一开始空的日志的状态一定是满足日志匹配原则的, 一致性检查保证了当日志添加时的日志匹配原则. 因此, 只要 AppendEntries 返回成功的时候, 领导人就知道追随者们的日志和它的是一致的了.

在一般情况下, 领导人和追随者们的日志保持一致, 因此 AppendEntries 一致性检查通常不会失败. 然而, 领导人的崩溃会导致日志不一致(旧的领导人可能没有完全复制完日志中的所有条目). 这些不一致会导致一系列领导人和追随者崩溃. **图-7** 阐述了一些追随者可能和新的领导人日志不同的情况. 一个追随者可能会丢失掉领导人上的一些条目, 也有可能包含一些领导人没有的条目, 也有可能两者都会发生. 丢失的或者多出来的条目可能会持续多个任期.

在 Raft 算法中, 领导人通过强制追随者们复制它的日志来处理日志的不一致. 这就意味着, 在追随者上的冲突日志会被领导者的日志覆盖. **5.4节**会说明当添加了一个额外的限制之后这是安全的.

为了使得追随者的日志同自己的一致, 领导人需要找到追随者同它的日志一致的地方, 然后删除追随者在该位置之后的条目, 然后将自己在该位置之后的条目发送给追随者. 这些操作都在 AppendEntries RPC 进行一致性检查时完成. 领导人给每一个追随者维护了一个nextIndex, 它表示领导人将要发送给该追随者的下一条日志条目的索引. 当一个领导人开始掌权时, 它会将nextIndex初始化为它的最新的日志条目索引数+1(**图-7** 中的 11). 如果一个追随者的日志和领导者的不一致, AppendEntries 一致性检查会在下一次 AppendEntries RPC 时返回失败. 在失败之后, 领导人会将nextIndex递减然后重试 AppendEntries RPC. 最终nextIndex 会达到一个领导人和追随者日志一致的地方. 这时, AppendEntries 会返回成功, 追随者中冲突的日志条目都被移除了, 并且添加所缺少的上了领导人的日志条目. 一旦 AppendEntries 返回成功, 追随者和领导人的日志就一致了, 这样的状态会保持到该任期结束.

如果需要的话, 算法还可以进行优化来减少 AppendEntries RPC 失败的次数. 例如, 当拒绝了一个 AppendEntries 请求, 追随者可以记录下冲突日志条目的任期号和自己存储那个任期的最早的索引. 通过这些信息, 领导人能够直接递减nextIndex跨过那个任期内所有的冲突条目; 这样的话, 一个冲突的任期需要一次 AppendEntries RPC, 而不是每一个冲突条目需要一次 AppendEntries RPC. 在实践中, 我们怀疑这种优化是否是必要的, 因为AppendEntries 一致性检查很少失败并且也不太可能出现大量的日志条目不一致的情况.

通过这种机制, 一个领导人在掌权时不需要采取另外特殊的方式来恢复日志的一致性. 它只需要使用一些常规的操作, 通过响应 AppendEntries 一致性检查的失败能使得日志自动的趋于一致. 一个领导人从来不会覆盖或者删除自己的日志(**表-3** 中的领导人只增加原则).

这个日志复制机制展示了在第2章中阐述的所希望的一致性特性: Raft 能够接受, 复制并且应用新的日志条目只要大部分的服务器是正常的. 在通常情况下, 一条新的日志条目可以在一轮 RPC 内完成在集群的大多数服务器上的复制; 并且一个速度很慢的追随者并不会影响整体的性能.

### 5.4 安全性

之前的章节中讨论了 Raft 算法是如何进行领导选取和复制日志的. 然而, 到目前为止这个机制还不能保证每一个状态机能按照相同的顺序执行同样的指令. 例如, 当领导人提交了若干日志条目的同时一个追随者可能宕机了, 之后它又被选为了领导人然后用新的日志条目覆盖掉了旧的那些, 最后, 不同的状态机可能执行不同的命令序列.

这一节通过在领带人选取部分加入了一个限制来完善了 Raft 算法. 这个限制能够保证对于固定的任期, 任何的领导人都拥有之前任期提交的全部日志条目(**表-3** 中的领导人完全原则). 有了这一限制, 日志提交的规则就更清晰了. 最后, 我们提出了对于领导人完全原则的简单证明并且展示了它是如何修正复制状态机的行为的.

#### 5.4.1 选举限制

在所有的以领导人为基础的一致性算法中, 领导人最终必须要存储全部已经提交的日志条目. 在一些一致性算法中, 例如: Viewstamped Replication, 即使一开始没有包含全部已提交的条目也可以被选为领导人. 这些算法都有一些另外的机制来保证找到丢失的条目并将它们传输给新的领导人, 这个过程要么在选举过程中完成, 要么在选举之后立即开始. 不幸的是, 这种方式大大增加了复杂性. Raft 使用了一种更简单的方式来保证在新的领导人开始选举的时候在之前任期的所有已提交的日志条目都会出现在上边, 而不需要将这些条目传送给领导人. 这就意味着日志条目只有一个流向: 从领导人流向追随者. 领导人永远不会覆盖已经存在的日志条目.

Raft 使用投票的方式来阻止没有包含全部日志条目的服务器赢得选举. 一个候选人为了赢得选举必须要和集群中的大多数进行通信, 这就意味着每一条已经提交的日志条目最少在其中一台服务器上出现. 如果候选人的日志至少和大多数服务器上的日志一样新(up-to-date, 这个概念会在下边有详细介绍), 那么它一定包含有全部的已经提交的日志条目. RequestVote RPC 实现了这个限制: 这个 RPC(远程过程调用)包括候选人的日志信息, 如果它自己的日志比候选人的日志要新, 那么它会拒绝候选人的投票请求.

Raft 通过比较日志中最后一个条目的索引和任期号来决定两个日志哪一个更新. 如果两个日志的任期号不同, 任期号大的更新; 如果任期号相同, 更长的日志更新.

#### 5.4.2 提交之前任期的日志条目

正如 **5.3节** 中描述的那样, 只要一个日志条目被存在了在多数的服务器上, 领导人就知道当前任期就可以提交该条目了. 如果领导人在提交之前就崩溃了, 之后的领导人会试着继续完成对日志的复制. 然而, 领导人并不能断定存储在大多数服务器上的日志条目一定在之前的任期中被提交了. **图-8** 说明了一种情况, 一条存储在了大多数服务器上的日志条目仍然被新上任的领导人覆盖了.

为了消除 **图-8** 中描述的问题, Raft 从来不会通过计算复制的数目来提交之前人气的日志条目. 只有领导人当前任期的日志条目才能通过计算数目来进行提交. 一旦当前任期的日志条目以这种方式被提交, 那么由于日志匹配原则(Log Matching Property), 之前的日志条目也都会被间接的提交. 在某些情况下, 领导人可以安全的知道一个老的日志条目是否已经被提交(例如, 通过观察该条目是否存储到所有服务器上), 但是 Raft 为了简化问题使用了一种更加保守的方法.

因为当领导人从之前任期复制日志条目时日志条目保留了它们最开始的任期号, 所以这使得 Raft 在提交规则中增加了额外的复杂性. 在其他的一致性算法中, 如果一个新的领导人要从之前的任期中复制日志条目, 它必须要使用当前的新任期号. Raft 的方法使得判断日志更加容易, 因为它们全程都保持着同样的任期号. 另外, 和其它的一致性算法相比, Raft 算法中的新领导人会发送更少的之前任期的日志条目(其他算法必须要发送冗余的日志条目并且在它们被提交之前来重新排序).

#### 5.4.3 安全性论证

给出了完整的 Raft 算法, 现在我们能够更精确的论证领导人完全原则(Leader Completeness)(这基于 **9.2节** 提出的安全性证明). 我们假定领导人完全原则是不成立的, 然后推导出矛盾. 假定任期 T 的领导人 leaderT 在它的任期提交了一个日志条目, 但是这条日志条目并没有存储在之后的任期中的领导人上. 我们设大于 T 的最小的任期 U 的领导人(leaderU)没有存储这条日志条目.

1. 在 leaderU 选举时一定没有那条被提交的日志条目(领导人从来不会删除或者覆盖日志条目).

2. leaderT 复制了这个条目到集群的大多数的服务器上. 因此, 只是有一台服务器(投票者)即接收了来自 leaderT 的日志条目并且给 leaderU 投票, 就像 **图-9** 中所示那样. 这个投票者是产生矛盾的关键.

3. 投票者必须在给 leaderU 投票之前接收来自 leaderT 的日志条目; 否则它会拒绝来自 leaderT 的 AppendEntries 请求(它的当前任期会比 T 要大).

4. 投票者会在它给 leaderU 投票时存储那个条目, 因为任何中间的领导人都保有该条目(基于假设), 领导人从来不会移除这个条目, 并且追随者也只会在和领导人冲突时才会移除日志条目.

5. 投票者给 leaderU 投票了, 所以 leaderU 的日志必须和投票者的一样新. 这就导致了一个矛盾.

6. 首先, 如果投票者和 leaderU 最后一条日志条目的任期号相同, 那么 leaderU 的日志一定和投票者的一样长, 因此它的日志包含全部投票者的日志条目. 这是矛盾的, 因为在假设中投票者和 leaderU 包含的已提交条目是不同的.

7. 除此之外, leaderU 的最后一条日志的任期号一定比投票者的大. 另外, 它也比 T 要大, 因为投票者的最后一条日志条目的任期号最小也要是 T(它包含了所有任期 T 提交的日志条目). 创建 leaderU 最后一条日志条目的上一任领导人必须包含已经提交的日志条目(基于假设). 那么, 根据日志匹配原则(Log Matching), leaderU 也一定包含那条提交的日志条目, 这也是矛盾的.

8. 这时就完成了矛盾推导. 因此, 所有比任期 T 大的领导人一定包含所有在任期 T 提交的日志条目.

9. 日志匹配原则(Log Matching)保证了未来的领导人也会包含被间接提交的日志条目, 就像 **图-8** 中(d)时刻索引为2的条目。

通过给出领导人完全原则(Leader Completeness), 我们能够证明 **表-3** 中的状态机安全原则(State Machine Safety), 状态机安全原则(State Machine Safety)讲的是如果一台服务器将给定索引上的日志条目应用到了它自己的状态机上, 其它服务器的同一索引位置不可能应用的是其它条目. 在一个服务器应用一条日志条目到它自己的状态机中时, 它的日志必须和领导人的日志在该条目和之前的条目上相同, 并且已经被提交. 现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期; 日志完全特性(Log Completeness Property)保证拥有更高任期号的领导人会存储相同的日志条目, 所以之后的任期里应用某个索引位置的日志条目也会是相同的值. 因此, 状态机安全特性是成立的.

最后, Raft 算法需要服务器按照日志中索引位置顺序应用日志条目. 和状态机安全特性结合起来看, 这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中, 并且是按照相同的顺序.


































Functional programming in Scala