# 可理解的一致性算法研究(raft)

## 摘要

Raft 是一种用来管理日志复制的一致性算法. 它与 Paxos 是等效的, 同时在性能上也相近,但是它采用了不同的结构;这使得 Raft 更容易理解, 也更易于建立实际的系统。为了便于理解，Raft 将一致性算法分为了几个部分，例如领导选取 (leader selection)，日志复制(log replication) 和安全性 (safety), 同时它**使用了更强的一致性来减少了必须需要考虑的状态**。从用户学习的结果来看, Raft 比 Paxos 更容易上手. Raft 还引入了一种新的机制动态改变集群成员，它使用**重叠大多数(overlapping majorities)**来保证安全。


## 1 介绍

一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器失效也能正常提供服务.正是因为这样的特点，他们在构建大规模可靠的软件系统中扮演了关键角色。在过去的数十年中 , Paxos 统治着有关一致性算法的讨论: 大多数一致性算法的实现都基于它或者受它影响, 并且 Paxos 也成了教授一致性知识的主要载体.

不幸的是, 尽管在降低它的复杂性方面做了许多努力, Paxos 依旧很难理解. 并且, Paxos 需要经过复杂的修改才能应用于实际系统. 这些导致了系统构建者和学生都十分头疼.

在被 Paxos 折磨之后， 我们开始寻找一种在系统构建和教学上表现更好的一致性算法. 我们的首要目标是让它易于理解: 我们能不能定义一种面向实际系统并且比 Paxos 更容易学习的的一致性算法呢? 并且, 我们希望这种算法能凭直觉就能明白, 这对于一个系统构建者来说是十分必要的. 让一个算法工作起来很重要, 知道它是如何工作的更重要.

我们工作的结果是一种新的一致性算法, 叫做 Raft. 在设计 Raft 的过程中我们应用了许多专门的技巧来使其便于理解, 包括算法分解(分为领导选取--leader selection, 日志复制--log replication 和安全性--safety) 和状态空间减少(state space reduction) (相对于 Paxos, Raft 减少了不确定性和服务器之间状态不一致的可能). 一项在两所学校的43个学生中进行的研究表明, Raft 比 Paxos 明显要更容易理解:在学习了两种算法之后, 其中的33个学生能够更好的回答 Raft 的问题.

Raft 算法和已有的算法在某些地方很相似(主要是 Oki 和 Liskov 的 Viewstamped Replication).但是 Raft 有几个新的特性：

*    强领导 (Strong Leader): Raft 强化了领导的作用. 例如, 日志条目只从领导者发往其他服务器. 这样就简化了对日志复制的管理, 使得 Raft 更易于理解.
*    领导选取 (Leader Selection): Raft 使用随机定时器来选取领导者. 这种方法仅仅是在所有一致性算法都需要的心跳机制上增加了一点变化，然而它却使得解决冲突更简单和快速。
*   成员变化 (Membership Change): Raft 为了调整集群中成员使用了新的**联合一致性(joint consensus)的方法, 这种方法中大多数不同配置的机器在转换关系的时候会交迭(overlap).** 这使得在配置改变的时候, 集群仍然能够正常运作.

我们认为, raft 在教学和实际应用方面比 Paxos 和其他算法表现更好. 它比其他算法更简单, 更容易理解；它满足一个实际系统的所有需求；它拥有许多开源的实现并且被许多公司使用；它的安全性已经被证实；并且它的效率也具有竞争力。

这篇论文剩下的部分会讲如下内容：复制状态机 (replicated state machine) 问题 (第2节), 讨论 Paxos 的优缺点(第3节), 描述我们对可理解性的一般方法(第4节), 陈述 Raft 一致性算法(第5~8节), 评价 Raft 算法(第9节), 对相关工作的讨论(第10节).


## 2 复制状态机 (Replicated State Machine)

一致性算法是在复制状态机的背景下提出来的. 在这个方法中，一组服务器中的所有状态机计算并获取同样的状态, 即使有一些服务器崩溃了, 这组服务器(作为一个整体)仍然能继续运行. 复制状态机在分布式系统中被用于解决许多容错问题, 例如 GFS, HDFS 还有 RAMCloud 这些大规模的系统都有一个单独的集群领导，通常用一个单独的复制状态机来进行领导选取和存储配置信息来应对领导者的崩溃. 使用复制状态机的例子包括 Chubby 和 ZooKeeper.

![Replicated State Machine](https://raw.githubusercontent.com/21moons/memo/master/res/img/raft_1.jpg)

<font size=2>图1: 复制状态机的架构。一致性算法管理复制日志, 它包括来自客户的状态机命令。所有的状态机都处理相同的命令序列，因此会得到相同的执行结果</font>

如图-1所示，复制状态机是通过复制日志来实现的。每台服务器保存的日志都是相同的，日志中包含一系列的命令，状态机会执行相同顺序的命令。因为每一台计算机的状态机都是确定的(唯一的输入对应唯一的输出)，所以所有的状态机都次都会计算出相同的状态，并最终得到相同的结果.

如何保证复制日志一致就是一致性算法的工作了。在一台服务器上，一致性模块接受客户端的命令并且把命令加入到它的日志中。它和其他服务器上的一致性模块进行通信来确保每一个日志最终包含相同序列的请求，即使有一些服务器宕机了。一旦这些命令被正确的复制了，每一个服务器的状态机都会按同样的顺序去执行它们，然后将结果返回给客户端。最终，这些服务器看起来就像一台可靠的状态机







http://blog.csdn.net/luoyhang003/article/details/61915666


| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |

dog | bird | cat
----|------|----
foo | foo  | foo
bar | bar  | bar
baz | baz  | baz


Functional programming in Scala