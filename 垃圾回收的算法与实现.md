## 1.9 评价标准
评价 GC 算法的性能时，我们采用以下 4 个标准。
* 吞吐量
* 最大暂停时间
* 堆使用效率
* 访问的局部性

较大的吞吐量和较短的最大暂停时间不可兼得
可用的堆越大，GC 运行越快;
相反，越想有效地利用有限的堆，GC 花费的时间就越长。

# 2 GC标记-清除算法
GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的内存空间重新得到利用。

标记所花费的时间是与 “活动对象的总数” 成正比的, 标记阶段就是 “遍历对象并标记” 的处理过程。
在 GC 标记 - 清除算法的使用过程中会逐渐产生被细化的分块，不久后就会导致无数的小分块散布在堆的各处。我们称这种状况为碎片化 (fragmentation)。

## 2.6 位图标记
在单纯的 GC 标记 - 清除算法中，用于标记的位是被分配到各个对象的头中的。也就是说，算法是把对象和头一并处理的。然而之前在 2.3.3 节中也提过，这跟<font color=#fd0209 size=5 >写时复制技术</font>不兼容。
在堆为多个的情况下，一般会为每个堆都准备一个位图表格。

## 2.6 延迟清除法




# 3 引用计数法
对象保存自己的引用次数, 不需要回收算法遍历依赖关系树来标记
这种算法将垃圾回收放在了引用计数操作中,一旦对象引用计数为0即刻回收, 优点是可即刻回收垃圾，最大暂停时间短, 对程序实时性影响较小, 缺点是引用计数保存在对象中, 垃圾回收算法与对象耦合, 对象引用计数字段也会占用内存空间， 另外就是不支持对象的循环引用

## 3.4 延迟引用计数法

计数器值增减处理繁重的原因之一是从根的引用变化频繁

* 优点
在延迟引用计数法中，程序延迟了根引用的计数，将垃圾一并回收。通过延迟，减轻了因根引用频繁发生变化而导致的计数器增减所带来的额外负担。

* 缺点
为了延迟计数器值的增减，垃圾不能马上得到回收，这样一来垃圾就会压迫堆，我们也就失去了引用计数法的一大优点 — 可即刻回收垃圾。
另外，scan_zct() 函数导致最大暂停时间延长了。执行 scan_zct() 函数所费的时间与 \$zct 的大小成正比。\$zct 越大，要搜索的对象就越多，妨碍 mutator 运作的时间也就越长。要想缩减因 scan_zct() 函数而导致的暂停时间，就要缩小 \$zct。但是这样一来调用 scan_zct() 函数的频率就增加了，也压低了吞吐量。很明显这样就本末倒置了


## 3.5 Sticky引用计数法

有很多研究表明，很多对象一生成马上就死了。也就是说，在很多情况下，计数器的值会在 0 到 1 的范围内变化，很少出现 5 位计数器溢出这样的情况，为了节约内存空间，提出了下面的解决方法

### 解决方法: 混合GC标记-清除算法与引用计数算法

* 一开始就把所有对象的计数器值设为 0
* 不标记对象，而是对计数器进行增量操作
*  为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索

像这样，只要把引用计数法和 GC 标记 - 清除算法结合起来，在计数器溢出后即使对象成了垃圾，程序还是能回收它。另外还有一个优点，那就是还能回收循环引用的垃圾。
但是在进行标记处理之前，必须重置所有的对象和计数器(避免可能的溢出造成的影响)。此外，因为标记方式从设置标志位变成了使用计数器进行计数，所以需要多次 (次数和被引用数一致) 查找活动对象。
考虑到这一点的话，显然在这里进行的标记处理比以往的 GC 标记 - 清除算法中的标记处理要花更多的时间。也就是说，吞吐量会相应缩小。


## 3.6 1位引用计数法
1 位引用计数法 (1bit Reference Counting) 是 Sticky 引用计数法的一个极端例子, 计数器只有 1 位大小, 用 0 表示被引用数为 1, 用 1 表示被引用数大于等于 2.



