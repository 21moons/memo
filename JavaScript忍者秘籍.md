## JavaScript 函数是第一类公民, 可以是参数，变量或返回值, 也可以在函数内部定义函数
 
## !! 用于将表达式转换为布尔值
 
## 并不是函数声明多少个参数就得传入多少个参数,函数是否可以成功处理这些参数完全取决于函数本身的定义,所以 JavaScript 的函数重载并非定义多个函数, 而是通过一个函数对参数数量和类型的识别来实现

## this 表示执行上下文
 
## call 和 apply 方法
apply 传入的是单个数组, call 传入的是参数列表

## 函数的 length 属性表明函数声明了多少个参数, arguments.length 表示调用时传入了多少个参数

## arguments 参数引用的不是真正的数组, 我们可以用 for 循环进行遍历, 但它缺乏基本数组应该有的所有方法, 包括 slice()
 
## javascript 函数可以有属性
 
## typeof 判断变量类型
 
## 在页面生命周期内, 浏览器可以将函数作为各种类型的事件处理程序进行调用
 
## 函数中变量的作用域开始于声明处, 结束于函数尾
 
## 内部函数在当前函数的任何地方都可用(包括定以前, 这称为提升)

## 函数的形参列表和实际参数列表的长度可以是不同的, 未赋值的参数被设置为 undefined, 多出的参数被无视
 
## 一个函数在创建时允许其访问并操作函数以外的变量, 为达到该目的而创建的作用域就叫做闭包(closure)
 
## 每个函数调用都会传入两个隐式参数 arguments 和 this, arguments 是实际传入的参数集合, this 是对函数运行上下文的引用
 
## 可以用不同的方法进行函数调用, 不同的调用机制决定了函数上下文的不同
* 作为普通函数进行调用时, 上下文是全局对象(window)
* 作为方法进行调用时, 其上下文是拥有该方法的对象
* 作为构造器进行调用时, 其上下文是一个新分配的对象
* 通过函数的 apply() 或 call() 方法进行调用时, 上下文可以设置成任意值
 
## 匿名函数在 javascipt 中是常见的, 关于匿名函数:
* 函数 name 属性为空的都属于匿名函数，匿名函数除了简化函数定义方式外，还削弱了函数的对外部环境的可见性
* web 程序开发中, 函数式编程风格是我们要做事情的重要核心, 没有必要为只使用一次的函数命令
* 为了不让不必要的函数名称污染全局命名空间, 需要创建大量的小型函数进行传递

## 闭包不仅包含函数声明, 还包含了函数声明的那一时刻点上该函数作用域中的所有变量
函数作用域是单向可见的, inner 函数可以看见 outter 函数中定义的变量, 反过来则不成立
 
## 闭包的实现是在外层函数执行结束后,**外部变量保存了对内部函数的引用** 或 **返回了内部函数**

## javascript 中我们可以为任何对象添加属性和方法, 包括数据

## call 和 apply 方法作为所有函数的方法存在

## 可以直接调用原生类型的函数, 例如Array.prototype.slice

## 函数也有 length 属性, 表示函数定义时声明了多少个参数, arguments.length 表示调用时传入了多少个参数

## 重载函数的方法
```javascript
function addMethod(object, name, fn){
  var old = object[name];
  object[name] = function(){
       if (fn.length = arguments.length)
           return fn.apply(this, arguments);
       else if (typeof old == "function")
           return old.apply(this, arguments);
  };
}
```

page 107
 
 

